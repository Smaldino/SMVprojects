MODULE main

VAR 
    -- Philosopher states
    p1_state : {thinking, hungry, eating};
    p2_state : {thinking, hungry, eating};
    p3_state : {thinking, hungry, eating};
    -- Fork ownership 
    fork1 : {none, held_by_p1, held_by_p2}; -- btw by p1 and p2
    fork2 : {none, held_by_p2, held_by_p3}; -- btw by p2 and p3

INIT
    p1_state = thinking & p2_state = thinking & p3_state = thinking &
    fork1 = none & fork2 = none;

TRANS
    --P1 can become hungry anytime
    (p1_state = thinking -> (next(p1_state) = hungry | next(p1_state) = thinking)) & 
    --P2 can become hungry anytime
    (p2_state = thinking -> (next(p2_state) = hungry | next(p2_state) = thinking)) &
    --P3 can become hungry anytime
    (p3_state = thinking -> (next(p3_state) = hungry | next(p3_state) = thinking)) &

    -- P1 actions
    (p1_state = hungry & fork1 = none ->
        next(p1_state) = hungry & next(fork1) = held_by_p1 &
        next(p2_state) = p2_state & next(p3_state) = p3_state & next(fork2) = fork2) |
    (p1_state = hungry & fork1 = held_by_p1 ->
        next(p1_state) = thinking & next(fork1) = none &
        next(p2_state) = p2_state & next(p3_state) = p3_state & next(fork2) = fork2) |
    (next(p1_state) = p1_state & next(fork1) = fork1 &
        next(p2_state) = p2_state & next(p3_state) = p3_state & next(fork2) = fork2) &

    -- P3 actions
    (p3_state = hungry & fork2 = none ->
        next(p3_state) = hungry & next(fork2) = held_by_p3 &
        next(p1_state) = p1_state & next(p2_state) = p2_state & next(fork1) = fork1) |
    (p3_state = hungry & fork2 = held_by_p3 ->
        next(p3_state) = thinking & next(fork2) = none &
        next(p1_state) = p1_state & next(p2_state) = p2_state & next(fork1) = fork1) |
    (next(p3_state) = p3_state & next(fork2) = fork2 &
        next(p1_state) = p1_state & next(p2_state) = p2_state & next(fork1) = fork1) &
    
    -- P2 actions
    (p2_state = hungry & fork1 = none & fork2 = none ->
        next(p2_state) = eating & next(fork1) = held_by_p2 & next(fork2) = held_by_p2 &
        next(p1_state) = p1_state & next(p3_state) = p3_state) |
    (p2_state = eating & fork1 = held_by_p2 & fork2 = held_by_p2 ->
        next(p2_state) = thinking & next(fork1) = none & next(fork2) = none &
        next(p1_state) = p1_state & next(p3_state) = p3_state) |
    (next(p2_state) = p2_state & next(fork1) = fork1 & next(fork2) = fork2 &
        next(p1_state) = p1_state & next(p3_state) = p3_state);

INVAR

    (fork1 = held_by_p1 -> p1_state = hungry) &
    (fork1 = held_by_p2 -> p2_state = hungry | p2_state = eating) &
    (fork2 = held_by_p2 -> p2_state = hungry | p2_state = eating) &
    (fork2 = held_by_p3 -> p3_state = hungry);

SPEC
    AG (p2_state = eating -> (fork1 = held_by_p2 & fork2 = held_by_p2))
